" Download vim-plug if it does not exist.
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl --fail --location --create-dirs --output ~/.vim/autoload/plug.vim
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  augroup vimplug_group
    autocmd!
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  augroup END
endif

filetype plugin on
syntax on
call plug#begin('~/.vim/plugged')

" Color Scheme.
Plug 'romainl/flattened'

" Handy bracket mappings
Plug 'tpope/vim-unimpaired'
" UNIX shell commands.
Plug 'tpope/vim-eunuch'
" Commenting out text.
Plug 'tpope/vim-commentary'
" Surrounding text.
Plug 'machakann/vim-sandwich'
" Indent character.
Plug 'yggdroot/indentline'
" Snippets.
Plug 'joereynolds/vim-minisnip'

" Auto completion and linting.
Plug 'w0rp/ale'
Plug 'prabirshrestha/async.vim'
Plug 'prabirshrestha/vim-lsp'

" Git and VCS integration.
Plug 'mhinz/vim-signify'
Plug 'tpope/vim-fugitive'

" Fuzzy Searcher.
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all --xdg --no-update-rc' }
" File explorer.
Plug 'justinmk/vim-dirvish'

" Tags.
Plug 'ludovicchabant/vim-gutentags'

" Pane navigation with tmux.
Plug 'christoomey/vim-tmux-navigator'

" Latex.
Plug 'lervag/vimtex'
" Elixir.
Plug 'elixir-editors/vim-elixir'
" C++.
Plug 'octol/vim-cpp-enhanced-highlight'
" Rust.
Plug 'rust-lang/rust.vim'
" JavaScript.
Plug 'pangloss/vim-javascript'
Plug 'MaxMEllon/vim-jsx-pretty'
" Python.
Plug 'Vimjas/vim-python-pep8-indent'
" Go.
Plug 'fatih/vim-go'
call plug#end()

" Config for vim-sandwich.
let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)
let g:sandwich#recipes += [
      \ {'buns': ["( ", " )"], 'nesting': 1, 'match_syntax': 1, 'input': ['(']},
      \ {'buns': ["[ ", " ]"], 'nesting': 1, 'match_syntax': 1, 'input': ['[']},
      \ {'buns': ["{ ", " }"], 'nesting': 1, 'match_syntax': 1, 'input': ['{']},
      \ ]

" Config for indentLine.
let g:indentLine_char = '|'
let g:indentLine_concealcursor = 0
let g:indentLine_color_term = 10
let g:indentLine_fileTypeExclude = [ 'markdown', 'json' ]

" Config for ALE.
let g:ale_linters = {
      \ 'cpp': ['clang', 'cppcheck'],
      \ 'java': ['javac'],
      \ 'javascript': ['eslint'],
      \ 'python': ['autopep', 'flake8', 'pylint'],
      \ }
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_lint_on_text_changed = 'never'
let g:ale_set_quickfix = 0
let g:ale_sign_column_always = 1

" Config for vim-lsp.
let g:lsp_diagnostics_enabled = 0
let g:lsp_signs_enabled = 1

function! s:on_lsp_buffer_enabled() abort
    setlocal omnifunc=lsp#complete
    setlocal keywordprg=:LspHover
    nmap <buffer> gd <plug>(lsp-definition)
    nmap <buffer> gr <plug>(lsp-references)
endfunction

augroup lsp_buffer
  autocmd!
  autocmd User lsp_buffer_enabled call <SID>on_lsp_buffer_enabled()
augroup END

function! s:setup_lsp() abort
  if executable('pyls')
    call lsp#register_server({
          \ 'name': 'pyls',
          \ 'cmd': {server_info->['pyls']},
          \ 'whitelist': ['python'],
          \ })
  endif
  if executable('clangd')
    call lsp#register_server({
          \ 'name': 'clangd',
          \ 'cmd': {server_info->['clangd']},
          \ 'whitelist': ['c', 'cpp'],
          \ })
  endif
  if executable('rls')
    call lsp#register_server({
          \ 'name': 'rls',
          \ 'cmd': {server_info->['rls']},
          \ 'root_uri': {server_info->lsp#utils#path_to_uri(
            \ lsp#utils#find_nearest_parent_file_directory(
              \ lsp#utils#get_buffer_path(),
              \ ['Cargo.toml']
            \ )
          \ )},
          \ 'whitelist': ['rust'],
          \ })
  endif
  if executable('javascript-typescript-stdio')
    call lsp#register_server({
          \ 'name': 'javascript-typescript-langserver',
          \ 'cmd': {server_info->['javascript-typescript-stdio']},
          \ 'root_uri': {server_info->lsp#utils#path_to_uri(
            \ lsp#utils#find_nearest_parent_file_directory(
              \ lsp#utils#get_buffer_path(),
              \ ['tsconfig.json', 'package.json']
            \ )
          \ )},
          \ 'whitelist': ['javascript'],
          \ })
  endif
  if executable('elixir-ls')
    call lsp#register_server({
          \ 'name': 'elixir-ls',
          \ 'cmd': {server_info->['elixir-ls']},
          \ 'root_uri': {server_info->lsp#utils#path_to_uri(
            \ lsp#utils#find_nearest_parent_file_directory(
              \ lsp#utils#get_buffer_path(),
              \ ['mix.exs']
            \ )
          \ )},
          \ 'whitelist': ['elixir'],
          \ })
  endif
endfunction

augroup lsp_setup
  autocmd!
  autocmd User lsp_setup call <SID>setup_lsp()
augroup END

" Config for signify.
let g:signify_sign_change = '~'
let g:signify_sign_changedelete = '~_'
let g:signify_sign_delete_first_line = '_'
let g:signify_sign_show_count = 0
let g:signify_vcs_list = [ 'git' ]

" Config for vim-dirvish.
let g:dirvish_mode = ':sort ,^.*[\/],'

" Config for vim-gutentags.
let g:gutentags_cache_dir = '~/.vim/cache/tags/'
let g:gutentags_generate_on_empty_buffer = 1

" Config for vimtex.
let g:latex_view_general_viewer = 'zathura'
let g:tex_conceal = ''
let g:tex_flavor = 'latex'
let g:vimtex_compiler_latexmk = {
      \ 'callback' : 0,
      \ 'options': [
      \   '-file-line-error',
      \   '-interaction=nonstopmode',
      \   '-shell-escape',
      \   '-synctex=1',
      \   '-verbose',
      \ ]}
let g:vimtex_syntax_minted = [
      \ {'lang': 'c'},
      \ {'lang': 'cpp'},
      \ {'lang': 'java'},
      \ {'lang': 'python'},
      \ ]
let g:vimtex_view_method = 'zathura'

" Config for fzf.
let s:fzf_tags_options = [
      \ '--no-multi',
      \ '--delimiter= ',
      \ '--with-nth=1,2,3',
      \ '--nth=1,2',
      \ '--tiebreak=index',
      \ '--expect=ctrl-t,ctrl-v,ctrl-x',
      \ ]
let g:fzf_action = {
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-v': 'vsplit',
      \ 'ctrl-x': 'split',
      \ }
function! s:fzf_tags_sink(lines) abort
  if empty(a:lines)
    return
  endif
  echom a:lines
  let l:cmd = get(g:fzf_action, remove(a:lines, 0), 'e')
  let l:query = a:lines[0]
  let l:parts = split(l:query, '\%u00a0')
  let l:excmd = matchstr(l:parts[3], '^.*\ze;"')
  execute 'silent ' l:cmd l:parts[1]
  let [l:magic, &magic] = [&magic, 0]
  execute l:excmd
  let &magic = l:magic
endfunction

command! Tags call fzf#run(fzf#wrap({
      \ 'source': 'get-relative-tags '.join(map(tagfiles(), 'fnamemodify(v:val, ":S")')),
      \ 'options': s:fzf_tags_options,
      \ 'sink*': function('s:fzf_tags_sink'),
      \ }))
command! Buffers call fzf#run(fzf#wrap({
      \ 'source': filter(map(range(1, bufnr('$')), 'bufname(v:val)'), 'len(v:val)'),
      \ }))
command! MRU call fzf#run(fzf#wrap({
      \ 'source': v:oldfiles,
      \ }))

" Setting grepprg.
set grepformat^=%f:%l:%c:%m
if executable('rg')
  set grepprg=rg\ --vimgrep
elseif executable('ag')
  set grepprg=ag\ --vimgrep
elseif executable('ack')
  set grepprg=ack\ --nocolor\ --nogroup
else
  set grepprg=grep\ --recursive\ --line-number
endif

function! s:grep(args) abort
  return system(&grepprg.' '.a:args)
endfunction
command! -nargs=+ -complete=file_in_path -bar Grep cgetexpr <SID>grep(<q-args>) | echom "Finished grep."
command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr <SID>grep(<q-args>) | echom "Finished lgrep."

" Editing config.
set backspace=indent,eol,start
set infercase
set formatoptions=tcqj
set nojoinspaces
set pumheight=10
if exists('+completeopt')
  set completeopt=noinsert,menuone,noselect
endif

" Indentation and wrapping.
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set autoindent
set smarttab
set cindent
set nowrap

" Line numbers and column config.
set number
set relativenumber
set colorcolumn=100

" No beeping or error sounds.
set noerrorbells
set novisualbell
set belloff=all
set t_vb=
set timeoutlen=500

" Searching config.
set incsearch
set nohlsearch
set ignorecase
set smartcase

" Color scheme config.
set background=dark
silent! colorscheme flattened_dark

" Wildmenu config.
set wildmenu
set wildmode=full
set wildignore=.hg,.git,.svn                     " Version control.
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files.
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images.
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " Compiled object files.
set wildignore+=*.sw?                            " Vim swap files.
set wildignore+=*.DS_Store                       " OSX garbage.
set wildignore+=*.pdf,*.zip,*.so                 " Binaries.
set wildignore+=*.pyc,*.pyo                      " Python byte code.

" Displaying text.
set lazyredraw
set linebreak
set scrolloff=1
set sidescrolloff=5
set t_md=

" Folding.
set foldmethod=indent
set foldlevel=99

" List and fill chars config.
set list
set listchars=tab:¦\ ,nbsp:•,trail:·,extends:→,precedes:←
set fillchars+=vert:│

" Encoding config.
set encoding=utf-8
scriptencoding utf-8
set fileencoding=utf-8

" Mouse config.
set mouse=a
set nomousehide

" UI config.
set showtabline=1
set laststatus=2
set showmode
set showmatch
set showcmd
set cmdheight=2
set shortmess=aIT
set hidden

" Consistent splitting.
set splitbelow
set splitright

" Reading and writing files.
set autoread
set autowrite

" Vim info config.
set viminfo='500   " Remember marks for last 500 files.
set viminfo+=<1000 " Remember up to 1000 lines in each register.
set viminfo+=s1000 " Remember up to 1MB in each register.
set viminfo+=/1000 " Remember last 1000 search patterns.
set viminfo+=:1000 " Remember last 1000 commands.
set viminfo+=n$HOME/.vim/cache/viminfo/info

" Setting undo, backup, and swp directories.
set undofile
set undodir=~/.vim/cache/undo//
set backup
set backupdir=~/.vim/cache/backup//
set directory=~/.vim/cache/swp//

" Use histogram and indent-heuristic for diffs.
if has("patch-8.1.360")
  set diffopt=filler,internal,algorithm:histogram,indent-heuristic
endif

" Create necessary directories if they are missing.
if exists('*mkdir')
  for s:dir in ['/.vim/cache/backup/', '/.vim/cache/swp/', '/.vim/cache/undo/', '/.vim/cache/tags/', '/.vim/cache/viminfo/']
    if !isdirectory($HOME.s:dir)
      call mkdir($HOME.s:dir, 'p')
    endif
  endfor
endif

" Remap leader.
let g:mapleader="\<Space>"

" Regular j, k moves across visual lines.
" Numbered j, k moves across physical lines.
nnoremap <expr> j v:count ? 'm'''.v:count.'j' : 'gj'
nnoremap <expr> k v:count ? 'm'''.v:count.'k' : 'gk'

" Tab navigation.
nnoremap ]w gt
nnoremap [w gT

" Strip trailing whitespace.
function! s:strip_whitespace() abort
  let l:saved_search = @/
  let l:saved_view = winsaveview()
  %s/\s\+$//e
  call winrestview(l:saved_view)
  let @/ = l:saved_search
endfunction
command! StripWhitespace :call <SID>strip_whitespace()
nnoremap <leader>s :StripWhitespace<CR>

" Clipboard keybindings.
nnoremap <leader>y "+y
xnoremap <leader>y "+y
nnoremap <leader>p "+p
xnoremap <leader>p "+p

" Resize viewports with arrow keys.
nnoremap <silent> <Right> :vertical resize +2<CR>
nnoremap <silent> <Left> :vertical resize -2<CR>
nnoremap <silent> <Up> :resize +2<CR>
nnoremap <silent> <Down> :resize -2<CR>

command! Zoom call window#zoom()
nnoremap <silent> <leader>z :Zoom<CR>

" Reload .vimrc.
nnoremap <silent> <leader>r :source $MYVIMRC<CR>

" Fugitive bindings.
nnoremap <leader>gs :Gstatus<CR>
nnoremap <leader>gd :Gdiff<CR>
nnoremap <leader>gD :Gdiff HEAD<CR>
nnoremap <leader>gw :diffput<CR>
xnoremap <leader>gw :diffput<CR>
nnoremap <leader>gr :diffget<CR>
xnoremap <leader>gr :diffget<CR>
nnoremap <leader>gc :Gcommit<CR>
nnoremap <leader>gps :Gpush<CR>
nnoremap <leader>gpl :Gpull<CR>
nnoremap <leader>gl :Glog<CR>
nnoremap <leader>gL :Glog %<CR>
nnoremap <leader>gb :Gblame<CR>
nnoremap <leader>gg :Ggrep<Space>

" fzf keybindings.
nnoremap <leader>b :Buffers<CR>
nnoremap <leader>f :FZF<CR>
nnoremap <leader>m :MRU<CR>
nnoremap <leader>t :Tags<CR>

" Indentation in visual mode should stay in visual mode.
xnoremap > >gv
xnoremap < <gv

" Switching case in visual mode should stay in visual mode.
xnoremap u ugv
xnoremap U Ugv
xnoremap ~ ~gv

" Incrementing/decrementing numbers in visual mode should stay in visual mode.
xnoremap <C-a> <C-a>gv
xnoremap <C-x> <C-x>gv

" Visually select pasted or yanked text.
nnoremap gV `[v`]

" Consistent behavior.
nnoremap Y y$

" Sharing snippets.
command! -range=% SP <line1>,<line2>w !curl --form 'sprunge=<-' http://sprunge.us | tr --delete '\n' | xclip -in -selection clipboard
command! -range=% CL <line1>,<line2>w !curl --form 'clbin=<-' https://clbin.com | tr --delete '\n' | xclip -in -selection clipboard
command! -range=% VP <line1>,<line2>w !curl --form 'text=<-' http://vpaste.net | tr --delete '\n' | xclip -in -selection clipboard
command! -range=% IX <line1>,<line2>w !curl --form 'f:1=<-' ix.io | tr --delete '\n' | xclip -in -selection clipboard
command! -range=% TB <line1>,<line2>w !nc termbin.com 9999 | tr --delete '\n' | xclip -in -selection clipboard

" Backspace to switch to alternate file.
nnoremap <BS> <C-^>

" Write with sudo.
cmap w!! w !sudo tee > /dev/null %

" Bracket expansion.
inoremap {<CR> {<CR>}<C-o>O
inoremap {;    {<CR>};<C-o>O
inoremap (<CR> (<CR>)<C-o>O
inoremap (;    (<CR>);<C-o>O
inoremap [<CR> [<CR>]<C-o>O
inoremap [;    [<CR>];<C-o>O

" Highlight current line.
set cursorline

function! s:highlight() abort
  " General highlighting.
  highlight Normal ctermbg=8
  highlight NonText ctermbg=8
  highlight SpecialKey ctermbg=8
  highlight LineNr ctermbg=0
  highlight VertSplit ctermbg=8
  highlight SignColumn ctermbg=0
  highlight SpellBad cterm=underline

  " Highlighting for CursorLine.
  highlight clear CursorLine
  highlight CursorLine ctermbg=0
  highlight CursorLineNR ctermfg=14 ctermbg=0

  " Highlighting for Signify symbols.
  highlight SignifySignAdd ctermfg=2 ctermbg=0
  highlight SignifySignChange ctermfg=3 ctermbg=0
  highlight SignifySignDelete ctermfg=1 ctermbg=0

  " Highlighting for ALE symbols
  highlight ALEErrorSign ctermfg=1 ctermbg=0
  highlight ALEWarningSign ctermfg=3 ctermbg=0

  " Highlighting for LaTeX.
  highlight texMathMatcher ctermbg=none
  highlight texMathZoneX ctermbg=none
  highlight texRefLabel ctermbg=none
  highlight texStatement ctermbg=none

  " Highlighting for Markdown.
  highlight def link markdownItalic NONE
  highlight def link markdownItalicDelimiter NONE
  highlight def link markdownBold NONE
  highlight def link markdownBoldDelimiter NONE
  highlight def link markdownBoldItalic NONE
  highlight def link markdownBoldItalicDelimiter NONE
  highlight markdownItalic ctermfg=4
  highlight markdownItalicDelimiter ctermfg=4
  highlight markdownBold ctermfg=4
  highlight markdownBoldDelimiter ctermfg=4
  highlight markdownBoldItalic ctermfg=4
  highlight markdownBoldItalicDelimiter ctermfg=4

  " Highlighting for TabLine.
  highlight TabLine cterm=none ctermfg=8 ctermbg=10
  highlight TabLineSel cterm=none ctermfg=8 ctermbg=14
  highlight TabLineFill cterm=none ctermfg=0 ctermbg=0
  highlight TabNum cterm=none ctermfg=8 ctermbg=10
  highlight TabNumSel cterm=none ctermfg=8 ctermbg=14

  " Highlighting for statusline.
  highlight StatusLineDark ctermfg=12 ctermbg=0
  highlight StatusLineLight ctermfg=0 ctermbg=14
  highlight StatusLineAccent ctermfg=15 ctermbg=1
endfunction

" Highlighting autocommands.
augroup highlighting_group
  autocmd!
  autocmd VimEnter,ColorScheme * call <SID>highlight()
augroup end

" Quickfix relative autocommands.
augroup quickfix_group
  autocmd!
  autocmd QuickFixCmdPost [^l]* nested cwindow
  autocmd BufHidden,QuitPre * nested if &filetype != 'qf' | silent! lclose | endif
augroup END

" Cursorline autocommands.
augroup cursorline_group
  autocmd!
  autocmd WinLeave * set nocursorline
  autocmd WinEnter,BufEnter * set cursorline
augroup END

" Numbering autocommands.
augroup numbering_group
  autocmd!
  autocmd WinLeave * set norelativenumber
  autocmd WinEnter,BufEnter * if &filetype != 'qf' && &filetype != 'help' | set relativenumber | endif
augroup END

" Searching highlighting autocommands.
augroup search_group
  autocmd!
  autocmd CmdlineEnter [/\?] set hlsearch
  autocmd CmdlineLeave [/\?] set nohlsearch
augroup END
